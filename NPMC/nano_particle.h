#ifndef RNMC_NANO_PARTICLE_H
#define RNMC_NANO_PARTICLE_H

#include "../core/sql.h"
#include "../core/sql_types.h"
#include "../core/queues.h"
#include "sql_types.h"
#include "NPMC_types.h"

#include <vector>
#include <cmath>
#include <functional>
#include <csignal>
#include <set>
#include <map>

struct NanoParticle {
    // maps a species index to the number of degrees of freedom
    std::vector<int> degrees_of_freedom;

    // maps site index to site data
    std::vector<NanoSite> sites;

    // 2D vector representing the pairwise distance between two sites
    std::vector<std::vector<double>> distance_matrix;

    // maps site ids to sites which are within a cutoff distance
    std::vector<std::vector<int>> site_dependency;

    // maps site ids to sit
    std::vector<NanoReaction> initial_reactions;

    // Remove this since we don't have concrete reaction_ids
    // maps site ids to reaction ids involving the site.
    // TODO: Check if performance is better using std::vector<std::set<int>> or std::vector<std::vector<int>>
    std::vector<std::set<int>> site_reaction_dependency;

    // maps interaction index to interaction data
    std::vector<Interaction> all_interactions;
    std::vector<Interaction> one_site_interactions;
    std::vector<Interaction> two_site_interactions;

    // maps site_0_index, site_0_state to interaction data
    std::vector<std::vector<std::vector<Interaction>>> one_site_interactions_map;
    // maps site_0_index, site_1_index, site_0_state, site_1_state to interaction data
    std::vector<std::vector<std::vector<std::vector<std::vector<Interaction>>>>> two_site_interactions_map;

    // initial state of the simulations.
    // initial_state[i] is a local degree of freedom
    // from the species at site i.
    std::vector<int> initial_state;
    std::vector<int> current_state;

    // std::vector<double> initial_propensities;

    // list mapping reaction_ids to reactions
    std::vector<NanoReaction> reactions;

    double one_site_interaction_factor;
    double two_site_interaction_factor;
    double interaction_radius_bound;

    std::function<double(double)> distance_factor_function;

    // constructor
    NanoParticle(
        SqlConnection &nano_particle_database,
        SqlConnection &initial_state_database,
        NanoParticleParameters parameters);

    double site_distance_squared(NanoSite s1, NanoSite s2);

    // maps a site index to the indices of its neighbors
    // within the spatial decay radius
    std::vector<std::vector<int>> compute_site_neighbors();

    void compute_reactions(
        const std::vector<int> &state,
        std::vector<NanoReaction> &reactions,    
        std::vector<std::set<int>> &site_reaction_dependency
    );
    void compute_new_reactions(
        const int site_0_id,
        const int other_site_id,
        const int site_0_state,
        const std::vector<int> &state,
        std::vector<NanoReaction> &new_reactions
    );

    void compute_distance_matrix();

    void update_state(
        std::vector<int> &state,
        NanoReaction reaction
    );

    // updates are passed directly to the solver, but the model
    // classes don't have a reference to the solver (otherwise,
    // the would need to be parameterized over a Solver type, which
    // feels akward). The way around this is that the model class computes
    // all the propensity updates required, and then passes them into an
    // update_function lambda which is generated by the Simulation class from
    // core.

    void update_reactions(
        const std::vector<int> &state,
        NanoReaction reaction,
        std::vector<std::set<int>> &current_site_reaction_dependency,
        std::vector<NanoReaction> &current_reactions);

    // convert a history element as found a simulation to history
    // to a SQL type.
    NanoWriteTrajectoriesSql history_element_to_sql(
        int seed,
        NanoTrajectoryHistoryElement history_element);

    NanoWriteStateSql state_history_element_to_sql(
        int seed,
        NanoStateHistoryElement state_history_element);

    WriteCutoffSql cutoff_history_element_to_sql(
        int seed,
        CutoffHistoryElement cutoff_history_element);

    void checkpoint(SqlReader<NanoReadStateSql> state_reader, 
        SqlReader<ReadCutoffSql> cutoff_reader, 
        SqlReader<NanoReadTrajectoriesSql> trajectory_reader, 
        std::map<int, std::vector<int>> &temp_seed_state_map, 
        std::map<int, int> &temp_seed_step_map, 
        SeedQueue &temp_seed_queue, 
        std::map<int, double> &temp_seed_time_map, 
        NanoParticle &model);


    void store_checkpoint(std::vector<NanoStateHistoryElement> &state_packet,
        std::vector<int> &state,
        unsigned long int &seed, int step, double time, 
        std::vector<CutoffHistoryElement> &cutoff_packet);    
};


#endif